#!/usr/bin/python

import os
import re
import sys
import sets
import time
import socket
import logging
import optparse
import cStringIO
import threading
import logging.handlers
import xml.sax.expatreader

from xml.sax import saxutils, make_parser
from xml.sax.handler import ContentHandler, feature_external_ges

Gratia = None
StorageElement = None
StorageElementRecord = None

log = None
timestamp = time.time()
SLEEP_TIME = 30*60
XRD_NAME = 'Xrootd'
XRD_AREA_NAME = '%s Area Tokens' % XRD_NAME
XRD_STATUS = "Production"

class XrootdSummaryParser(ContentHandler):

    def __init__(self, dataCallback):
        self.dataCallback = dataCallback

    def startDocument(self):
        self.cur_key = ()
        self.cur_val = None

    def emitData(self, key, val):
        try:
            self.dataCallback(key, val)
        except SystemExit, KeyboardInterrupt:
            raise
        except:
            pass

    def startElement(self, name, attrs):
        if name.startswith('statistics'):
            return
        if name == 'stats':
            key = str(attrs.get('id', 'stats'))
        else:
            key = str(name)
        self.cur_key += (key, )

    def endElement(self, name):
        if self.cur_key:
            self.cur_key = self.cur_key[:-1]

    def characters(self, ch):
        if self.cur_key and (self.cur_key[-1] in ['host', 'chars', 'lp', 'rp',
                'name']):
            self.emitData(self.cur_key, str(ch))
        else:
            try:
                val = int(str(ch))
                self.emitData(self.cur_key, val)
            except:
                pass

invalid_xml_re = re.compile('</statistics toe="\d+">')
class XrdDataHandler(object):

    def __init__(self, callback):
        parser = make_parser()
        handler = XrootdSummaryParser(callback)
        parser.setContentHandler(handler)
        parser.setFeature(feature_external_ges, False)
        self.parser = parser

    def handle(self, data):
        data = invalid_xml_re.sub("</statistics>", data)
        fp = cStringIO.StringIO(data)
        self.parser.parse(fp)

def print_handler(key, val):
    print key, val

def udp_server(data_handler, port=3333, bind="0.0.0.0"):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server_socket.bind((bind, 3333))
    buf = 4096
    while 1:
        data, addr = server_socket.recvfrom(buf)
        data_handler.handle(data)

class XrootdXmlParser(xml.sax.expatreader.ExpatParser):

    def __init__(self, bufsize=2**9):
        self._bufsize = bufsize
        xml.sax.expatreader.ExpatParser.__init__(self)

    def parse(self, source):
        source = saxutils.prepare_input_source(source)

        self._source = source
        self._cont_handler.setDocumentLocator(xml.sax.expatreader.ExpatLocator(\
            self))

        file = source.getByteStream()
        buffer = file.read(self._bufsize)

        while buffer != "":
            self.feed(buffer)
            buffer = file.read(self._bufsize)

    def feed(self, data, **kw):
        data = invalid_xml_re.sub("</statistics>", data)
        xml.sax.expatreader.ExpatParser.feed(self, data, **kw)

def file_handler(data_handler, input_file):
    handler = XrootdSummaryParser(data_handler)
    parser = XrootdXmlParser()
    parser.setContentHandler(handler)
    parser.setFeature(feature_external_ges, False)
    fp = open(input_file, 'r')
    parser.feed("<statisticstop>")
    parser.parse(fp)
    parser.feed("</statisticstop>")
    handler.endDocument()

class HostInfo(object):

    def __init__(self, hostname):
        self.hostname = hostname
        self.id_to_area = {}
        self.area_info = {}
        self.path_info = {}

    def add_path(self, id):
        self.path_info[id] = {}

    def add_path_stat(self, id, stat, val):
        self.path_info[id][stat] = val

    def add_area(self, id, name):
        self.id_to_area[id] = name
        self.area_info[name] = {}

    def add_area_stat(self, id, stat, val):
        name = self.id_to_area[id]
        self.area_info[name][stat] = val

    def get_total_used_kb(self):
        return self.get_total_kb() - self.get_total_free_kb()

    def get_total_free_kb(self):
        return sum([int(i.get("free", 0)) for i in self.path_info.values()])

    def get_total_kb(self):
        return sum([int(i.get("tot", 0)) for i in self.path_info.values()])

    def get_area_info(self, area_name):
        return self.area_info.get(area_name, {})

    def get_area_names(self):
        return self.id_to_area.values()

    def get_hostname(self):
        return self.hostname

    def __str__(self):
        out  = '\tHost: %s\n' % self.hostname
        out += '\t\tPaths:\n'
        for i in range(len(self.path_info)):
            for key, val in self.path_info[str(i)].items():
                out += '\t\t\t%i %s: %s\n' % (i, key, val)
        out += '\t\tAreas:\n'
        for area, info in self.area_info.items():
            out += '\t\t\tArea %s:\n' % area
            for key, val in info.items():
                 out += '\t\t\t\t%s: %s\n' % (key, val)
        return out

def get_se():
    config_se = Gratia.Config.getConfigAttribute("SEName")
    if not config_se:
        raise Exception("SEName attribute not found in ProbeConfig")
    return config_se

def get_version():
    config_version = Gratia.Config.getConfigAttribute("XrootdVersion")
    if not config_version:
        raise Exception("XrootdVersion attribute not found in ProbeConfig")
    return config_version

class GratiaHandler(object):

    def __init__(self):
        self.host_info = {}
        self.cur_host = None
        self.cur_host_info = None
        t = threading.Thread(target=self.process)
        t.setDaemon(True)
        t.setName("Gratia Processing Thread")
        self.thread = t
        self.stop = False
        self.stop_exception = None
        t.start()

    def process(self):
        try:
            time.sleep(SLEEP_TIME)
        except KeyboardInterrupt, SystemExit:
            raise
        except Exception, e:
            log.exception(e)
        try:
            self.summary
        except KeyboardInterrupt, SystemExit:
            raise
        except Exception, e:
            log.exception(e)
        try:
            t = threading.Thread(target=self.process)
            t.setDaemon(True)
            t.setName("Gratia Processing Thread")
            self.thread = t
            t.start()
        except Exception, e:
            log.exception(e)
            self.stop_exception = e
            self.stop = True
            raise

    def handle(self, key, val):
        log.debug("GratiaHandler processed message: %s, %s" % (".".join(key),
            str(val)))
        if self.stop:
            raise self.stop_exception
        # Switch host if necessary.
        if key == ('info', 'host'):
           if val != self.cur_host:
               self.cur_host = val
               self.cur_host_info = self.host_info.get(val, None)
               if not self.cur_host_info:
                   self.cur_host_info = HostInfo(val)
                   self.host_info[val] = self.cur_host_info
        if not self.cur_host:
            return

        # Parse OSS stats only
        if key[0] != 'oss':
            return
        # Parse path information
        elif key[1:] == ('paths',):
            for i in range(val):
                self.cur_host_info.add_path(str(i))
            return
        elif key[1] == 'paths':
            if len(key) < 4:
                return
            id = key[2]
            stat = key[3]
            self.cur_host_info.add_path_stat(id, stat, val)
        # Parse area information
        elif key[1] == 'space' and key[3] == 'name':
            # Format: oss.space.<integer>.name
            self.cur_host_info.add_area(key[2], val)
        elif key[1] == 'space':
            self.cur_host_info.add_area_stat(key[2], key[3], val)

    def summary(self):
        # Update our global timestamp so we don't have to do this in all the
        # Gratia send functions.
        global timestamp
        timestamp = time.time()

        print "%s Host info:" % XRD_NAME
        for host, host_info in self.host_info.items():
            print "**", host
            print str(host_info)
            self.send_node_props(host_info)
        self.send_system_props()
        self.send_master_area()
        self.send_area_props()

    def send_node_props(self, host_info):
        """
        Send the storage information to Gratia for a single host.
        """
        se = get_se()
        version = get_version()
        name = host_info.get_hostname()
        unique_id = '%s:Pool:%s' % (se, name)
        parent_id = "%s:SE:%s" % (se, se)

        sa = StorageElement.StorageElement()
        sar = StorageElementRecord.StorageElementRecord()
        sa.UniqueID(unique_id)
        sa.Name(name)
        sa.SE(se)
        sa.SpaceType("Pool")
        sa.Implementation(XRD_NAME)
        sa.Version(version)
        sa.Status(XRD_STATUS)
        sa.ParentID(parent_id)
        sa.Timestamp(timestamp)
        sar.Timestamp(timestamp)
        sar.UniqueID(unique_id)
        sar.MeasurementType("raw")
        sar.StorageType("disk")
        sar.TotalSpace(1024*host_info.get_total_kb())
        sar.FreeSpace(1024*host_info.get_total_free_kb())
        sar.UsedSpace(1024*host_info.get_total_used_kb())
        Gratia.Send(sa)
        Gratia.Send(sar)

    def send_system_props(self):
        # Standard Gratia properties
        se = get_se()
        version = get_version()
        unique_id = "%s:SE:%s" % (se, se)
        parent_id = unique_id

        # Calculate the raw path totals for all hosts
        tot, used, free = 0, 0, 0
        for host_info in self.host_info.values():
            tot += host_info.get_total_kb()
            used += host_info.get_total_used_kb()
            free += host_info.get_total_free_kb()
        # Convert back to bytes
        tot *= 1024
        used *= 1024
        free *= 1024

        # Send out gratia information
        sa = StorageElement.StorageElement()
        sar = StorageElementRecord.StorageElementRecord()
        sa.UniqueID(unique_id)
        sa.Name(se)
        sa.SE(se)
        sa.SpaceType("SE")
        sa.Implementation(XRD_NAME)
        sa.Version(version)
        sa.Status(XRD_STATUS)
        sa.ParentID(parent_id)
        sa.Timestamp(timestamp)
        sar.UniqueID(unique_id)
        sar.MeasurementType("raw")
        sar.StorageType("disk")
        sar.TotalSpace(tot)
        sar.FreeSpace(free)
        sar.UsedSpace(used)
        sar.Timestamp(timestamp)
        Gratia.Send(sa)
        Gratia.Send(sar)

    def send_master_area(self):
        se = get_se()
        name = XRD_AREA_NAME
        space_type = 'Area'
        version = get_version()

        unique_id = '%s:%s:%s' % (se, space_type, name)
        parent_id = '%s:SE:%s' % (se, se)

        sa = StorageElement.StorageElement()
        sa.UniqueID(unique_id)
        sa.Name(name)
        sa.SE(se)
        sa.SpaceType(space_type)
        sa.Implementation(XRD_NAME)
        sa.Version(get_version())
        sa.Status(XRD_STATUS)
        sa.ParentID(parent_id)
        sa.Timestamp(timestamp)
        Gratia.Send(sa)

    def send_area_props(self):

        # Build the set of all area names
        all_areas = sets.Set()
        for host_info in self.host_info.values():
             all_areas.update(host_info.get_area_names())

        se = get_se()
        version = get_version()

        for area_name in all_areas:
            # Collect relevant area statistics
            tot, used, free, quot = 0, 0, 0, 0
            for host_info in self.host_info.values():
                info = host_info.get_area_info(area_name)
                area_tot = info.get('tot', 0)
                tot += area_tot
                free += 1024*info.get('free', 0)
                area_quot = info.get('qta', 0)
                if area_quot > area_tot:
                    quot += area_tot
                else:
                    quot += area_quot
                used += 1024*info.get('usg', 0)

            # Generic stuff for the StorageElement
            if quot:
                space_type = "Quota"
            else:
                space_type = "Directory"
            unique_id = '%s:%s:%s' % (se, space_type, area_name)
            parent_id = '%s:Area:%s' % (se, XRD_AREA_NAME)

            sa = StorageElement.StorageElement()
            sa.Name(area_name)
            sa.SE(se)
            sa.UniqueID(unique_id)
            sa.ParentID(parent_id)
            sa.SpaceType(space_type)
            sa.Implementation(XRD_NAME)
            sa.Version(version)
            sa.Status(XRD_STATUS)
            sa.Timestamp(timestamp)
            sar = StorageElementRecord.StorageElementRecord()
            sar.UniqueID(unique_id)
            sar.MeasurementType("logical")
            sar.StorageType("disk")
            sar.TotalSpace(tot)
            sar.FreeSpace(free)
            sar.UsedSpace(used)
            sar.Timestamp(timestamp)
            Gratia.Send(sa)
            Gratia.Send(sar)

    def __del__(self):
        self.summary()

def parse_opts():
    parser = optparse.OptionParser()
    parser.add_option("-d", "--daemon", help="Run as daemon; automatically " \
        "background the process.", default=False, action="store_true",
        dest="daemon")
    parser.add_option("-l", "--logfile", help="Log file location.  Defaults " \
        "to the Gratia logging infrastructure.", dest="logfile")
    parser.add_option("-i", "--input", help="Input file name; if this option" \
        " is given, the process does not listen for UDP messages", dest="input")
    parser.add_option("-p", "--port", help="UDP Port to listen on for " \
        "messages.  Overridden by Gratia ProbeConfig.", type="int",
        default=3333, dest="port")
    parser.add_option("--gratia_home", help="Location of the top-level " \
        "Gratia directory; defaults to $VDT_LOCATION/gratia",
        dest="gratia_home")
    parser.add_option("--gratia_config", help="Location of the Gratia config;" \
        " defaults to $GRATIA_HOME/xrootd-storage/ProbeConfig",
        dest="gratia_config")
    parser.add_option("-b", "--bind", help="Listen for messages on a " \
        "specific address; defaults to 0.0.0.0.  Overridden by Gratia " \
        "ProbeConfig", default="0.0.0.0", dest="bind")
    parser.add_option("-v", "--verbose", help="Enable verbose logging to " \
        "stdout.", default=False, action="store_true", dest="verbose")
    parser.add_option("--print_only", help="Only print data recieved; do not" \
        " send to Gratia.", dest="print_only", action="store_true")

    opts, args = parser.parse_args()

    # Expand our input paths:
    if opts.gratia_home:
        opts.gratia_home = os.path.expanduser(opts.gratia_home)
    if opts.input:
        opts.input = os.path.expanduser(opts.input)
    if opts.logfile:
        opts.logfile = os.path.expanduser(opts.logfile)
    if opts.gratia_config:
        opts.gratia_config = os.path.expanduser(opts.gratia_config)

    # Bootstrap Gratia home
    gratia_home = None
    if opts.gratia_home and os.path.exists(opts.gratia_home):
        gratia_home = opts.gratia_home
    vdt_location = os.environ.get("VDT_LOCATION", "/opt/vdt")
    if not gratia_home:
        gratia_home = os.path.join(os.environ['VDT_LOCATION'], "gratia")

    # Initialize logging
    logfile = os.path.join(gratia_home, "var", "logs", "xrootd-storage.log")
    if opts.logfile:
        logfile = opts.logfile
    try:
        fp = open(logfile, 'w')
    except Exception, e:
        raise Exception("Could not open Xrootd-Storage logfile, %s, for " \
            "write.  Error: %s." % (logfile, str(e)))
    global log
    log = logging.getLogger("XrdStorage")
    log.setLevel(logging.DEBUG)
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    handler = logging.handlers.RotatingFileHandler(
        logfile, maxBytes=20*1024*1024, backupCount=5)
    handler.setLevel(logging.DEBUG)
    handler.setFormatter(formatter)
    log.addHandler(handler)
    if opts.verbose:
        handler = logging.StreamHandler()
        handler.setLevel(logging.DEBUG)
        handler.setFormatter(formatter)
        log.addHandler(handler)

    # Bootstrap Gratia environment
    log.debug("Gratia home: %s" % gratia_home)
    probe_home = os.path.join(gratia_home, "probe", "xrootd-storage")
    if os.path.exists(probe_home) and probe_home not in sys.path:
        sys.path.insert(0, probe_home)
        log.debug("Gratia Probe home: %s" % probe_home)
    common_home = os.path.join(gratia_home, "probe", "common")
    if os.path.exists(common_home) and common_home not in sys.path:
        sys.path.insert(0, common_home)
        log.debug("Gratia Common home: %s" % common_home)
    services_home = os.path.join(gratia_home, "probe", "services")
    if os.path.exists(services_home) and services_home not in sys.path:
        sys.path.insert(0, services_home)
        log.debug("Gratia Services home: %s" % services_home)
    log.debug("Probe python search path: %s" % ", ".join(sys.path))
    global Gratia    
    Gratia = __import__("Gratia")
    global StorageElement
    StorageElement = __import__("StorageElement")
    global StorageElementRecord
    StorageElementRecord = __import__("StorageElementRecord")

    # Initialize Gratia
    gratia_config = None
    if opts.gratia_config and os.path.exists(gratia_config):
        gratia_config = opts.gratia_config
    elif probe_home:
        tmp = os.path.join(probe_home, "ProbeConfig")
        if os.path.exists(tmp):
            gratia_config = tmp
    if not gratia_config:
        raise Exception("Unable to find a suitable ProbeConfig to use!")
    Gratia.Initialize(gratia_config)

    return opts

def main():
    opts = parse_opts()

    if opts.print_only:
        my_handler = print_handler
    else:
        gratia_handler = GratiaHandler()
        my_handler = gratia_handler.handle

    handler = XrdDataHandler(my_handler)
    if not opts.input:
        udp_server(handler, port=opts.port, bind=opts.bind)
    else:
        input = opts.input
        try:
            fp = open(input, 'r')
        except Exception, e:
            raise Exception("Could not open input file, %s, for read due to " \
                "exception %s." % (input, str(e)))
        file_handler(my_handler, opts.input)

    if not opts.print_only:
        gratia_handler.summary()

if __name__ == '__main__':
    main()

