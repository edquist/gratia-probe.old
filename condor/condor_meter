#!/usr/bin/python
#
# condor_meter - Python-based Condor probe for Gratia
#       By Brian Bockelman; Nov 4, 2011
#

import os
import re
import sys
import time
import optparse

from gratia.common.Gratia import DebugPrint
import gratia.common.GratiaCore as GratiaCore
import gratia.common.Gratia as Gratia

prog_version = "%%%RPMVERSION%%%"
prog_revision = '$Revision$'
max_batch_size = 500

min_start_time = time.time() - 120*86400

def parse_opts():

    global ProbeConfig

    parser = optparse.OptionParser(usage="%prog [options] dir1 dir2")
    parser.add_option("-f", "--gratia_config", help="Location of the Gratia config; "
        "defaults to /etc/gratia/condor/ProbeConfig.", dest="gratia_config",
        default="/etc/gratia/condor/ProbeConfig")
    parser.add_option("-v", "--verbose", help="Enable verbose logging to stdout.",
        default=False, action="store_true", dest="verbose")

    opts, args = parser.parse_args()

    # Initialize Gratia
    if not opts.gratia_config or not os.path.exists(opts.gratia_config):
        raise Exception("Gratia config, %s, does not exist." % opts.gratia_config)
    GratiaCore.Initialize(opts.gratia_config)

    if opts.verbose:
        GratiaCore.Config.__DebugLevel = 5

    if not args:
        args = [GratiaCore.Config.getConfigAttribute("DataFolder")]
        DebugPrint(5, "Defaulting processing directory to %s as none are specified on command line" % args[0])

    return opts, args

condor_version_re = re.compile("^\$CondorVersion:\s*(.*)\s*\$\n\$CondorPlatform:\s*(.*)\s*\$")
def getCondorVersion():
    fd = os.popen("condor_version")
    version = fd.read()
    if fd.close():
        raise Exception("Unable to invoke condor_version")
    m = condor_version_re.match(version.strip())
    if m:
        return "%s / %s" % m.groups()
    raise Exception("Unable to parse condor_version output: %s" % version)
    return version.strip()

logfile_re = re.compile("^history\.(?:.*?\#)?\d+\.\d+")
def logfiles_to_process(args):
    for arg in args:
        if os.path.isfile(arg) and os.stat(arg).st_size:
            DebugPrint(5, "Processing logfile %s" % arg)
            yield arg
        elif os.path.isdir(arg):
            for logfile in os.listdir(arg):
                m = logfile_re.match(logfile)
                if m:
                    DebugPrint(5, "Processing logfile %s" % logfile)
                    yield os.path.join(arg, logfile)

condor_history_re = re.compile("^history.(\d+)\.(\d+)")
def main():

    try:
        opts, dirs = parse_opts()
    except Exception, e:
        print >> sys.stderr, str(e)
        sys.exit(1)

    version = getCondorVersion()

    GratiaCore.RegisterReporter("condor_meter.pl", "%s (tag %s)" % \
        (prog_revision, prog_version))
    try:
        condor_version = getCondorVersion()
    except SystemExit:
        raise
    except KeyboardInterrupt:
        raise
    except Exception, e:
        print >> sys.stderr, "Unable to successfully invoke condor_version"
        print >> sys.stderr, str(e)
        sys.exit(1)

    GratiaCore.RegisterService("Condor", condor_version)
    GratiaCore.setProbeBatchManager("condor")

    submit_count = 0
    submit_found = 0
    logs_found = 0
    logfile_errors = 0
    # Note we are not ordering logfiles by type, as we don't want to
    # pull them all into memory at once.
    for log in logfiles_to_process(dirs):
        logs_found += 1
        _, logfile = os.path.split(log)
        # Make sure the filename is in a reasonable format
        m = condor_history_re.match(logfile)
        if m:
            cnt_submit, cnt_found = process_history_file(log)
            if cnt_submit == cnt_found and cnt_submit > 0:
                DebugPrint(5, "Processed %i ClassAds from file %s" % (cnt_submit, log))
            else:
                DebugPrint(2, "Unable to process ClassAd from file (will add to quarantine): %s.  Submit count %d; found count %d" % (log, cnt_submit, cnt_found))
                GratiaCore.QuarantineFile(log, False)
                logfile_errors += 1
            submit_count += cnt_submit
            submit_found += cnt_found
        else:
            DebugPrint(2, "Ignoring history file with invalid name: %s" % log)

    DebugPrint(2, "Number of logfiles processed: %d" % logs_found)
    DebugPrint(2, "Number of logfiles with errors: %d" % logfile_errors)
    DebugPrint(2, "Number of usage records submitted: %d" % submit_count)
    DebugPrint(2, "Number of usage records found: %d" % submit_count)

def process_history_file(logfile):

    count_submit = 0
    count_found = 0
    try:
        fd = open(logfile, 'r')
    except IOError, ie:
        DebugPrint(2, "Cannot process %s: (errno=%d) %s", logfile, ie.errno, ie.strerror)
        return 0, 0
    added_transient = False

    for classad in fd_to_classad(fd):
        count_found += 1
        if not classad:
            DebugPrint(5, "Ignoring empty classad from file: %s" % logfile)
            continue

        if not added_transient:
            classad['logfile'] = logfile
            added_transient = True
        try:
            r = classadToJUR(classad)
        except KeyboardInterrupt:
            raise
        except SystemExit:
            raise
        except Exception, e:
            DebugPrint(2, "Exception while converting the ClassAd to a JUR: %s" % str(e))
            raise
            continue

        if classad.get('CompletionDate', min_start_time) < min_start_time:
            DebugPrint(2, "Ignoring too-old job: %s" % str(classad.get("ClusterId", "Unknown")))
            continue

        response = GratiaCore.Send(r)
        if response[:2] == 'OK':
            count_submit += 1

    return count_submit, count_found

def setIfExists(func, classad, attr, comment=None, setstr=False):
    if attr in classad:
        val = classad[attr]
        if setstr:
            val = str(val)
        if not comment:
            func(val)
        else:
            func(val, comment)

global_job_id_re = re.compile("(.*)\#\d+\.?\d*\#.*")
def classadToJUR(classad):

    if 'ClusterId' not in classad:
        DebugPrint(2, "No data passed to classadToJUR: %s" % str(classad))
        return 0
    DebugPrint(5, "Creating JUR for %s" % classad['ClusterId'])

    resource_type = "Batch"
    if classad.get("GridMonitorJob", False):
        resource_type = "GridMonitor"
    elif 'MATCH_EXP_JOBGLIDEIN_ResourceName' in classad:
        resource_type = 'BatchPilot'
    r = Gratia.UsageRecord(resource_type)

    r.GlobalJobId(classad.get("UniqGlobalJobId", ""))

    if "ProcId" in classad and int(classad["ProcId"]) > 0:
        r.LocalJobId("%s.%s" % (classad["ClusterId"], classad["ProcId"]))
    else:
        r.LocalJobId(str(classad['ClusterId']))

    # I don't think ProcessId was ever correct - used to take the UDP port 
    # from the LastClaimId?

    setIfExists(r.LocalUserId, classad, "Owner")
    setIfExists(r.GlobalUsername, classad, "User")
    setIfExists(r.DN, classad, 'x509userproxysubject')
    setIfExists(r.VOName, classad, 'x509UserProxyFirstFQAN')
    setIfExists(r.ReportableVOName, classad, 'x509UserProxyVOName')

    if 'GlobalJobId' in classad:
        r.JobName(classad["GlobalJobId"])
        m = global_job_id_re.match(classad['GlobalJobId'])
        if m:
            submit_host = m.groups()[0]
            r.MachineName(submit_host)
            r.SubmitHost(submit_host)

    setIfExists(r.Status, classad, 'ExitStatus', "Condor Exit Status")

    setIfExists(r.WallDuration, classad, 'RemoteWallClockTime', "Was entered in seconds")

    if 'RemoteUserCpu' in classad:
        r.TimeDuration(classad['RemoteUserCpu'], "RemoteUserCpu")
    else:
        classad['RemoteUserCpu'] = 0

    if 'LocalUserCpu' in classad:
        r.TimeDuration(classad['LocalUserCpu'], 'LocalUserCpu')
    else:
        classad['LocalUserCpu'] = 0

    if 'RemoteSysCpu' in classad:
        r.TimeDuration(classad['RemoteSysCpu'], 'RemoteSysCpu')
    else:
        classad['RemoteSysCpu'] = 0

    if 'LocalSysCpu' in classad:
        r.TimeDuration(classad['LocalSysCpu'], 'LocalSysCpu')
    else:
        classad['LocalSysCpu'] = 0

    setIfExists(r.TimeDuration, classad, 'CumulativeSuspensionTime', 'CumulativeSuspensionTime')
    setIfExists(r.TimeDuration, classad, 'CommittedSuspensionTime', 'CommittedSuspensionTime')
    setIfExists(r.TimeDuration, classad, 'CommittedTime', 'CommittedTime')

    classad['SysCpuTotal'] = classad['RemoteSysCpu'] + classad['LocalSysCpu']
    r.CpuDuration(classad['SysCpuTotal'], "system", "Was entered in seconds")

    classad['UserCpuTotal'] = classad['RemoteUserCpu'] + classad['LocalUserCpu']
    r.CpuDuration(classad['UserCpuTotal'], "user", "Was entered in seconds")

    if 'CompletionDate' in classad and classad['CompletionDate'] > 0:
        r.EndTime(classad['CompletionDate'], "Was entered in seconds")

    setIfExists(r.StartTime, classad, 'JobStartDate', "Was entered in seconds")

    if 'LastRemoteHost' in classad:
        host = classad['LastRemoteHost'].split("@")[-1]
        if 'MATCH_EXP_JOBGLIDEIN_ResourceName' in classad:
            r.Host(host, True, classad['MATCH_EXP_JOBGLIDEIN_ResourceName'])
        else:
            r.Host(host, True)

    setIfExists(r.Queue, classad, "JobUniverse", "Condor's JobUniverse field", setstr=True)
    setIfExists(r.NodeCount, classad, 'MaxHosts', "max")

    if 'MachineAttrCpus0' in classad:
        r.Processors(classad['MachineAttrCpus0'], metric="max")

    if 'MyType' in classad:
        r.AdditionalInfo("CondorMyType", classad['MyType'])

    if 'AccountingGroup' in classad:
        r.AdditionalInfo("AccountingGroup", classad['AccountingGroup'])

    if 'ExitBySignal' in classad:
        if classad['ExitBySignal']:
            # Gratia expects lower-case; python produces "True".
            r.AdditionalInfo('ExitBySignal', 'true')
        else:
            r.AdditionalInfo('ExitBySignal', 'false')
    if 'ExitSignal' in classad:
        r.AdditionalInfo("ExitSignal", classad['ExitSignal'])
    if 'ExitCode' in classad:
        r.AdditionalInfo("ExitCode", classad['ExitCode'])
    if 'JobStatus' in classad:
        r.AdditionalInfo("condor.JobStatus", classad['JobStatus'])
    if 'GratiaJobOrigin' in classad:
        if classad['GratiaJobOrigin'] == "GRAM":
            r.Grid("OSG", "GratiaJobOrigin = GRAM")
        else:
            r.Grid("Local", "GratiaJobOrigin not GRAM")

    if 'logfile' in classad:
        r.AddTransientInputFile(classad["logfile"])


    networkPhaseUnit = classad.get('RemoteWallClockTime', '')
    total_network = 0
    for attr, val in classad.items():
        if attr.startswith("Network"):
            total_network += val
            r.Network(val, storageUnit='b', phaseUnit=networkPhaseUnit, metric=attr, description=attr)
    r.Network(total_network, storageUnit='b', phaseUnit=networkPhaseUnit, metric="total")

    return r

classad_bool_re = re.compile("^(\w{1,255}) = (true|True|TRUE|false|False|FALSE)$")
classad_int_re = re.compile("^(\w{1,255}) = (-?\d{1,30})$")
classad_double_re = re.compile("(\w{1,255}) = (-?\d{1,30}\.?\d{1,30}?)")
classad_string_re = re.compile("^(\S+) = \"(.*)\"$")
classad_catchall_re = re.compile("^(\S+) = (.*)$")
def fd_to_classad(fd):
    classad = {}
    for line in fd.readlines():
        line = line.strip()
        m = classad_bool_re.match(line)
        if m:
            attr, val = m.groups()
            if val.lower().find("true") >= 0:
                classad[attr] = True
            else:
                classad[attr] = False
            continue
        m = classad_int_re.match(line)
        if m:
            attr, val = m.groups()
            classad[attr] = int(val)
            continue
        m = classad_double_re.match(line)
        if m:
            attr, val = m.groups()
            classad[attr] = float(val)
            continue
        m = classad_string_re.match(line)
        if m:
            attr, val = m.groups()
            classad[attr] = str(val)
            continue
        m = classad_catchall_re.match(line)
        if m:
            attr, val = m.groups()
            classad[attr] = str(val)
            continue
        if not line:
            yield add_unique_id(classad)
            classad = {}
            continue
        DebugPrint(2, "Invalid line in ClassAd: %s" % line)

    yield add_unique_id(classad)
        
def add_unique_id(classad):
    if 'GlobalJobId' in classad:
        classad['UniqGlobalJobId'] = 'condor.%s' % classad['GlobalJobId']
        DebugPrint(6, "Unique ID: %s" % classad['UniqGlobalJobId'])
    return classad

if __name__ == "__main__":
    main()

