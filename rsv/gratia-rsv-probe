eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
  && eval 'exec perl -S $0 $argv:q'
  if 0;
########################################################################
# $Id$
#
# Check if Gratia probe installation is operating nominally.
#
# Based on gridftp-simple-probe v1.15
########################################################################

use strict;

use Getopt::Long;
use OSG_RSV_Probe_Base;
use Date::Manip;

######## Global variables go here ################################
our %o;                         ## Global hash to store "our" details i.e script's details
our %m_gratia;                  ## Store metric details.
our $probeType;                 ## Type of probe.

## Defaults needed even before global Initialize_Probe() is called 
##  (for listing the metrics in automated systems, usage info, etc.)
&Pre_Initialize_Probe ();

####################################
# Set parsing options
Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

####################################
# Process command line arguments.
GetOptions(
           "uri|u=s"                   => \$o{'serviceUri'},
           "metric|m=s" 	       => \$o{'metric'},
           "virtual-organization|v=s"  => \$o{'virtualorganization|v'},
           "timeout|t=i"               => \$o{'timeout'},
           "list-metric|l"             => \$o{'listmetric'},
	   "vdt-location=s"            => \$o{'VDT_LOCATION_LOCAL'},
	   "print-local-time"          => \$o{'printLocalTimezone'},
           "probe-type|p=s"            => \$probeType,
           "generate-gratia-script|ggs"=> \$o{'generateGratiaScript'},
           "gratia-script-loc|gsl=s"   => \$o{'gratiaLocationDir'},
           "gratia-config-file|gmpcf=s"=> \$o{'gratiaMetricProbeConfigFile'},
           "python-loc=s"              => \$o{'pythonToUse'},
           "version"                   => \$o{'version'},
           "test|T"                    => \$o{'test'},
           "help|h"                    => \$o{'help'},
          )
  or &OSG_RSV_Probe_Base::Print_Usage(\%o,\%m_gratia) && exit 1;

my $is_root = not $<; # Are we running as root?

## Set initial metrics
&Set_Metric();

if (${probeType}) {
  $m_gratia{metricName} = "net.sf.gratia.probe.${probeType}";
} else {
  $m_gratia{metricName} = "net.sf.gratia.probe.none";
}

## Initialize our (probe's) hash with commands, etc.
%o = %{&OSG_RSV_Probe_Base::Initialize_Probe (\%o)};

## Process serviceURI for hostName, etc.; copy stuff from %o to metric hash
%m_gratia = %{&OSG_RSV_Probe_Base::Initialize_Metric(\%o, \%m_gratia)};

## Process some simple options, and exit if they're specified after acting
##  i.e. --help or -l type arguments
&OSG_RSV_Probe_Base::Process_Informational_Arguments (\%o, \%m_gratia);

unless (${probeType}) {
  print STDERR
    "Probe name (condor, pbs, etc) must be specified with -p option!\n";
  &OSG_RSV_Probe_Base::Print_Usage(\%o,\%m_gratia);
  exit 1;
}
####################################
# Start tests
my @PYTHONPATH = split /:/, $ENV{PYTHONPATH};
unless (grep m&^\Q$ENV{VDT_LOCATION}/gratia/probe/common\E$&, @PYTHONPATH) {
  push @PYTHONPATH, "$ENV{VDT_LOCATION}/gratia/probe/common";
  $ENV{PYTHONPATH} = join(":", @PYTHONPATH);
}

# Check directories
unless (checkProbeDirs()) {
  setUnknown();
  normal_exit();
}

my $soaphost = getProbeConfigAttribute("SOAPHost");
my $probename = getProbeConfigAttribute("MeterName");
my $sitename = getProbeConfigAttribute("SiteName");
my $enabled = getProbeConfigAttribute("EnableProbe");
my $datafolder = getProbeConfigAttribute("DataFolder");
$datafolder =~ s&/$&&;
my $real_datafolder = `(cd "$datafolder" >/dev/null 2>&1 && /bin/pwd)`;
chomp $real_datafolder;

my $probe_in_cron = system("crontab -l 2>/dev/null| grep -e '^\\s*[^#].*gratia/probe/$probeType/' >/dev/null 2>&1") == 0;

################################
# Check some basic critical stuff
if ($probe_in_cron != 1) {
  if ($is_root) {
    setCritical();
    $m_gratia{detailsData} = "Probe $probename is not listed in crontab.";
    normal_exit();
  } else {
    setUnknown();
    $m_gratia{detailsData} = "Not root: cannot examine crontab";
  }
} elsif ($enabled ne "1") {
  setCritical();
  $m_gratia{detailsData} = "Probe $probename has EnableProbe not set to 1.";
  normal_exit();
} elsif ($probename =~ m&(?:generic|unknown)&i) {
  setCritical();
  $m_gratia{detailsData} = "MeterName $probename appears to be generic.";
  normal_exit();
}

#################################
# Check format of MeterName
my @colon_split = split /:/, $probename;
my $num_colons = $#colon_split;
if ($num_colons != 1) {
  setWarning();
  $m_gratia{detailsData} = "Not one and only one \`:' in MeterName $probename.";
}

################################
# Check sitename configuration.
if ((!$sitename) or $sitename =~ m&(?:generic|unknown)&i) {
  setWarning();
  add_to_details(<<EOF);
Configured SiteName "$sitename" is empty or generic.
EOF
}

################################
# Check last contact time with Gratia server.
my $probe_contact_check =
  `wget -q -O - 'http://$soaphost/gratia-administration/monitor-status.html?probename=$probename'`;
chomp $probe_contact_check;

$probe_contact_check =~ s&^last-contact=([^\s]+)\s+([^\s]+)$&${1}T${2}Z&;

my $cmpDate = DateCalc("today", "- 1 hour");
my $probe_seen_by_soaphost;
if (!$probe_contact_check) {
  setUnknown();
  add_to_details(<<EOF);
Gratia server $soaphost not responding to obtain last contact details.
EOF
} elsif ($probe_contact_check eq "last-contact=never") {
  setCritical();
  add_to_details(<<EOF);
Gratia server $soaphost has never seen probe $probename.
EOF
  normal_exit();
} elsif (Date_Cmp($probe_contact_check, $cmpDate) < 1) {
  setWarning();
  add_to_details(<<EOF);
Probe $probename has not been seen by Gratia collector $soaphost in >1h.
EOF
} else {
  $probe_seen_by_soaphost = 1;
}

################################
# Cross-check locally configured site name matches Gratia server sitename.
if ($probe_seen_by_soaphost) {
  my $probe_site_check =
    system("wget -q -O - 'http://$soaphost/gratia-administration/monitor-status.html?sitename=$sitename' 2>/dev/null | grep -e '^$probename: last-contact' >/dev/null 2>&1") == 0;

  if (!$probe_site_check) {
    setWarning();
    add_to_details(<<EOF);
Probe $probename not found in check of probes reporting to $soaphost from $sitename.
EOF
  }
}

################################
# Check log file for jobs reported.

################################
# Any checks specific to the probe type
probe_specific_checks();

# Set final status if we make it.
$m_gratia{metricStatus} = "OK"
  if ($m_gratia{metricStatus} eq "UNKNOWN");

normal_exit(1);

########################################################################
# Subroutines
########################################################################
sub add_to_details {
  $m_gratia{detailsData} = sprintf("$m_gratia{detailsData}\n%s",
                                   join("\n", @_));
}

sub normal_exit {
  return if $o{test} and not $_[0];
  ## Print metric, and we're all done!
  &OSG_RSV_Probe_Base::Print_Summary_Metric_Results (\%o,\%m_gratia);
  exit (&OSG_RSV_Probe_Base::Get_Probe_Exit_Value(\%o,\%m_gratia));
}

sub Pre_Initialize_Probe {
  $o{'revision'} = '$Revision$';

  $o{'helpIntro'} = <<'EOF';
Probe to check whether Gratia probes are configured and operating.
EOF
  $o{'helpOptions'} = <<'EOF';
 --probe-type <condor|pbs|...>    Required option. Probe expected in $VDT_LOCATION/gratia/probe/<probe-type>
 -p <condor|pbs|sge|...>          Short form of --probe-type.
EOF
}

sub Set_Metric {
  $m_gratia{'metricType'} = "status";
  $m_gratia{'serviceType'} = "Gratia probes";
  $m_gratia{'serviceVersion'} = ">= OSG CE 0.6.0";
}

sub setCritical {
  $m_gratia{metricStatus} = "CRITICAL";
}

sub setWarning {
  $m_gratia{metricStatus} = "WARNING" unless
    $m_gratia{metricStatus} eq "CRITICAL";
}

sub setUnknown {
  $m_gratia{metricStatus} = "UNKNOWN" unless
    $m_gratia{metricStatus} eq "CRITICAL";
}

sub probe_specific_checks {
  if ($probeType =~ m&(?:pbs|pbs-lsf|lsf)&i) {
    # PBS / LSF probe checks
    probe_check_pbs_lsf();
  } elsif ($probeType eq "condor") {
    probe_check_condor();
  }
}

sub probe_check_condor() {
  my $get_condor_config_cmd = ". $ENV{VDT_LOCATION}/setup.sh; condor_config_val PER_JOB_HISTORY_DIR";
  my $cmd_output = `$get_condor_config_cmd 2>&1`;
  my $status = $?;
  if ($status == 0) {
    # Make sure we're not suffering from alias problems.
    chomp $cmd_output;
    $cmd_output =~ s&/$&& if $cmd_output;
    $cmd_output = `(cd "$cmd_output" >/dev/null 2>&1 && /bin/pwd)`;
    chomp $cmd_output;
  }
  if ($status == 127 or $cmd_output =~ m&command not found&) {
    setUknown();
    add_to_details(<<EOF);
Unable to find condor_config_val command: could not check for presence
of PER_JOB_HISTORY_DIR attribute
$cmd_output
EOF
    return 0;
  } elsif ($cmd_output =~ m&^Not defined:&i or $status != 0 or not $cmd_output) {
    setWarning();
    add_to_details(<<EOF);
PER_JOB_HISTORY_DIR apparently not set in condor_config or condor_config_val
not operating as expected. Please ensure it is set to "$datafolder" in
condor_config or the schedd machine's local configuration.
EOF
      return 0;
  } else {
    if ($status == 0 and $cmd_output ne $datafolder) {
      setWarning();
      add_to_details(<<EOF);
PER_JOB_HISTORY_DIR is apparently set to "$cmd_output"
in condor_config. It should be set to
"$datafolder" as specified in ProbeConfig.
Please rectify in condor_config or the schedd machine's local configuration.
EOF
      return 0;
    }
  }
  return 1;
}

sub probe_check_pbs_lsf {
  my $URCOLLECTOR_LOC = "$ENV{VDT_LOCATION}/gratia/probe/$probeType";
  push @INC, $URCOLLECTOR_LOC;
  eval "require urCollector::Configuration";
  if ($@) {                     # FAILED to load configuration module
    setCritical();
    add_to_details(<<EOF);
Error loading urCollector::Configuration: $@
EOF
    normal_exit();
  }
  eval
    urCollector::Configuration::parseConf("$URCOLLECTOR_LOC/urCollector.conf");
  if ($@) {                     # FAILED to parse configuration
    setCritical();
    add_to_details(<<EOF);
Error reading $URCOLLECTOR_LOC/urCollector.conf: $@
EOF
    normal_exit();
  }
  # Check LRMS type setting
  if ($urCollector::Configuration::configValues{lrmsType} !~ m&(?:pbs|lsf)&i) {
    setCritical();
    add_to_details(<<EOF);
Unrecognized lrmsType $urCollector::Configuration::configValues{lrmsType} in urCollector.conf
EOF
    normal_exit();
  }
  # Check LRMS type matches probe type
  if ($probeType ne "pbs-lsf" and
      $urCollector::Configuration::configValues{lrmsType} ne $probeType) {
    setCritical();
    add_to_details(<<EOF);
Mismatch between probeType $probeType and configured lrmsType $urCollector::Configuration::configValues{lrmsType} in urCollector.conf.
EOF
    normal_exit();
  }
  unless ($is_root) { # Can't do these unless we're root.
    add_to_details(<<EOF);
Remaining checks on $urCollector::Configuration::configValues{lrmsType} require root privilege: please re-run this probe from the command line as root:
EOF
    add_to_details(join(" ", $0, @ARGV));
    return;
  }
  if ($urCollector::Configuration::configValues{lrmsType} eq "pbs") {
    my $dir = $urCollector::Configuration::configValues{pbsAcctLogDir};
    my $date = UnixDate("today", "%Y%m%d");
    if (not -d $dir) {
      setCritical();
      add_to_details(<<EOF);
Configured PBS log directory $dir does not exist.
Check pbsAcctLogDir in urCollector.conf.
EOF
      normal_exit();
    }
    my $nfiles = `ls -1 $dir | wc -l`;
    chomp $nfiles;
    if (!$nfiles) {
      setCritical();
      add_to_details(<<EOF);
No files found in configured PBS log directory $dir.
Check pbsAcctLogDir in urCollector.conf.
EOF
      normal_exit();
    } elsif ((not -e "$dir/$date") and (not -e "$dir/$date.gz")) {
      setWarning();
      add_to_details(<<EOF);
Configured PBS log directory $dir does not contain entries for today.
Check pbsAcctLogDir in urCollector.conf and contents of $dir.
EOF
    }
  } elsif ($urCollector::Configuration::configValues{lrmsType} eq "lsf") {
    my $dir = $urCollector::Configuration::configValues{lsfAcctLogDir};
    if (not -d $dir) {
      setCritical();
      add_to_details(<<EOF);
Configured LSF log directory $dir does not exist.
Check lsfAcctLogDir in urCollector.conf.
EOF
      normal_exit();
    } elsif (not -e "$dir/lsb.events") {
      setWarning();
      add_to_details(<<EOF);
No log file $dir/lsb.events.
Check lsfAcctLogDir in urCollector.conf and contents of $dir.
EOF
    }
  }
}

sub checkProbeDirs {
  my $probe_dir = "$ENV{VDT_LOCATION}/gratia/probe/$probeType";
  return (checkDirReadable($probe_dir, "$probeType probe directory") and
          checkFileReadable("$probe_dir/ProbeConfig"));
}

sub checkDirReadable {
  my ($dir, $description) = @_;
  if (-d $dir and -r $dir) {
    return 1;
  } else {
    add_to_details(<<EOF);
DirectoryCheck: $dir ($description) does not exist or is not readable.
EOF
    if (not $is_root) {
      add_to_details(<<EOF);
DirectoryCheck: Re-run as root?
EOF
    }
    return 0;
  }
}

sub checkFileReadable {
  my ($file, $description) = @_;
  if (-f $file and -r $file) {
    return 1;
  } else {
    add_to_details(<<EOF);
FileCheck: $file ($description) does not exist or is not readable.
EOF
    if (not $is_root) {
      add_to_details(<<EOF);
FileCheck: Re-run as root?
EOF
    }
    return 0;
  }
}

sub getProbeConfigAttribute {
  my $probeConfig_cmd = <<EOF;
( cd "$ENV{VDT_LOCATION}/gratia/probe/$probeType"; ../common/GetProbeConfigAttribute.py %s )
EOF

  my @results = ();

  foreach my $configAttribute (@_) {
    my $cmd = sprintf($probeConfig_cmd, $configAttribute);
    push @results, `$cmd 2>/dev/null`;
  }

  chomp @results;
  if (wantarray) {
    return @results;
  } else {
    return $results[0];
  }
}

__END__

### Local Variables:
### mode: cperl
### End:
